<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <meta name="generator" content="sphinx-4.1.1, furo 2021.07.05.beta38"/>
        <title>tomsup.ktom_functions - tomsup 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css" />
    


<style>
  :root {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #ff5454;
  --color-brand-content: #ff7575;
  
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --color-brand-primary: #ff8f8f;
  --color-brand-content: #ff8f8f;
  
    }
  }

  /* For allowing end-user-specific overrides */
  .override-light {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #ff5454;
  --color-brand-content: #ff7575;
  
  }
  .override-dark {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --color-brand-primary: #ff8f8f;
  --color-brand-content: #ff8f8f;
  
  }
</style><link media="(prefers-color-scheme: dark)" rel="stylesheet" href="../../_static/pygments_dark.css"></head>
  <body dir="">
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z"/>
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">tomsup 1.1.0 documentation</div></a>
    </div>
    <div class="header-right">
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../_static/icon.png" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../_static/icon.png" alt="Dark Logo"/>
  </div>
  
  
</a><form class="sidebar-search-container" method="get" action="../../search.html">
  <input class="sidebar-search" placeholder=Search name="q">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../using-tomsup.html">Using tomsup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Package References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../agent.html">Agent and AgentGroup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../payoffmatrix.html">PayoffMatrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plot.html">Plot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">Utility Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ktom_functions.html">k-ToM Functions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/KennethEnevoldsen/tomsup">GitHub Repository</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <main class="main">
    <div class="content">
      <article role="main">
        <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
          <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
        </label>
        <h1>Source code for tomsup.ktom_functions</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">This script contains all function related to the implementation of the</span>
<span class="sd">k-ToM agent.</span>
<span class="sd">"""</span>
<span class="c1"># For reference the parameter order of the k-ToM parameters is:</span>
<span class="c1"># [1] Volatility</span>
<span class="c1"># [2] Behavioural temperature</span>
<span class="c1"># [3] Dilution</span>
<span class="c1"># [4] Bias</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">tomsup.payoffmatrix</span> <span class="k">import</span> <span class="n">PayoffMatrix</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">expit</span> <span class="k">as</span> <span class="n">inv_logit</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">logit</span>


<span class="c1"># Learning subfunctions</span>
<div class="viewcode-block" id="p_op_var0_update"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.p_op_var0_update">[docs]</a><span class="k">def</span> <span class="nf">p_op_var0_update</span><span class="p">(</span><span class="n">prev_p_op_mean0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">prev_p_op_var0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">volatility</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    prev_p_op_mean0   (float)</span>
<span class="sd">    prev_p_op_var0    (float)</span>
<span class="sd">    volatility        (float)</span>

<span class="sd">    0-ToM updates variance / uncertainty on choice probability estimate</span>

<span class="sd">    Examples:</span>
<span class="sd">    &gt;&gt;&gt; p_op_var0_update(1, 0.2, 1)</span>
<span class="sd">    0.8348496471878395</span>
<span class="sd">    &gt;&gt;&gt; #Higher volatility results in a higher variance</span>
<span class="sd">    &gt;&gt;&gt; p_op_var0_update(1, 0.2, 1) &lt; p_op_var0_update (1, 0.2, 2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; #Mean close to 0.5 gives lower variance</span>
<span class="sd">    &gt;&gt;&gt; p_op_var0_update(1, 0.45, 1) &lt; p_op_var0_update (1, 0.2, 2)</span>
<span class="sd">    True</span>
<span class="sd">    """</span>
    <span class="c1"># Input variable transforms</span>
    <span class="n">volatility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">volatility</span><span class="p">)</span>
    <span class="n">prev_p_op_var0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">prev_p_op_var0</span><span class="p">)</span>

    <span class="n">prev_p_op_mean0</span> <span class="o">=</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">prev_p_op_mean0</span><span class="p">)</span>

    <span class="c1"># Update</span>
    <span class="n">new_p_op_var0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span>
        <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">volatility</span> <span class="o">+</span> <span class="n">prev_p_op_var0</span><span class="p">))</span> <span class="o">+</span> <span class="n">prev_p_op_mean0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prev_p_op_mean0</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Output variable transform</span>
    <span class="n">new_p_op_var0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">new_p_op_var0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_p_op_var0</span></div>


<div class="viewcode-block" id="p_op_mean0_update"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.p_op_mean0_update">[docs]</a><span class="k">def</span> <span class="nf">p_op_mean0_update</span><span class="p">(</span><span class="n">prev_p_op_mean0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">p_op_var0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">op_choice</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    prev_p_op_mean0 (float)</span>
<span class="sd">    p_op_var0       (float)</span>
<span class="sd">    op_choice       (int)</span>

<span class="sd">    0-ToM updates mean choice probability estimate</span>
<span class="sd">    """</span>
    <span class="c1"># Input variable transforms</span>
    <span class="n">p_op_var0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">p_op_var0</span><span class="p">)</span>

    <span class="c1"># Update</span>
    <span class="n">new_p_op_mean0</span> <span class="o">=</span> <span class="n">prev_p_op_mean0</span> <span class="o">+</span> <span class="n">p_op_var0</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">op_choice</span> <span class="o">-</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">prev_p_op_mean0</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># For numerical purposes, according to the VBA package</span>
    <span class="n">new_p_op_mean0</span> <span class="o">=</span> <span class="n">logit</span><span class="p">(</span><span class="n">inv_logit</span><span class="p">(</span><span class="n">new_p_op_mean0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">new_p_op_mean0</span></div>


<div class="viewcode-block" id="p_opk_approx_fun"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.p_opk_approx_fun">[docs]</a><span class="k">def</span> <span class="nf">p_opk_approx_fun</span><span class="p">(</span><span class="n">prev_p_op_mean</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">prev_param_var</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">prev_gradient</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    prev_p_op_mean  (numpy.ndarray)</span>
<span class="sd">    prev_param_var  (numpy.ndarray)</span>
<span class="sd">    prev_gradient   (numpy.ndarray)</span>
<span class="sd">    level           (int)</span>

<span class="sd">    Approximates the estimated choice probability of the opponent on the</span>
<span class="sd">    previous round.</span>
<span class="sd">    A semi-analytical approximation derived in Daunizeau, J. (2017)</span>

<span class="sd">    &gt;&gt;&gt; p_opk_approx_fun(prev_p_op_mean = np.array([0]), prev_param_var = np.array([[0, 0, 0]]), prev_gradient = np.array([[0, 0, 0]]), level = 1)</span>
<span class="sd">    """</span>
    <span class="c1"># Constants</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.205</span>
    <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.319</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">0.781</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mf">0.870</span>

    <span class="c1"># Input variable transforms</span>
    <span class="n">prev_param_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">prev_param_var</span><span class="p">)</span>

    <span class="c1"># Prepare variance by weighing with gradient</span>
    <span class="n">prev_var_prepped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">level_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
        <span class="n">prev_var_prepped</span><span class="p">[</span><span class="n">level_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_param_var</span><span class="p">[</span><span class="n">level_idx</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">prev_gradient</span><span class="p">[</span><span class="n">level_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>

    <span class="c1"># Equation</span>
    <span class="n">p_opk_approx</span> <span class="o">=</span> <span class="p">(</span><span class="n">prev_p_op_mean</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">prev_var_prepped</span> <span class="o">**</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">prev_var_prepped</span> <span class="o">**</span> <span class="n">d</span>
    <span class="p">)</span>

    <span class="c1"># Output variable transform</span>
    <span class="n">p_opk_approx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inv_logit</span><span class="p">(</span><span class="n">p_opk_approx</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">p_opk_approx</span></div>


<div class="viewcode-block" id="p_k_udpate"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.p_k_udpate">[docs]</a><span class="k">def</span> <span class="nf">p_k_udpate</span><span class="p">(</span><span class="n">prev_p_k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">p_opk_approx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">op_choice</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dilution</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    k-ToM updates its estimate of opponents sophistication level.</span>
<span class="sd">    If k-ToM has a dilution parameter, it does a partial forgetting of learned</span>
<span class="sd">    estimates.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; p_k_udpate(prev_p_k = np.array([1.]), p_opk_approx = np.array([-0.69314718]), op_choice = 1, dilution = None)</span>
<span class="sd">    """</span>
    <span class="c1"># Input variable transforms</span>
    <span class="n">p_opk_approx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">p_opk_approx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dilution</span><span class="p">:</span>
        <span class="n">dilution</span> <span class="o">=</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">dilution</span><span class="p">)</span>

    <span class="c1"># Do partial forgetting</span>
    <span class="k">if</span> <span class="n">dilution</span><span class="p">:</span>
        <span class="n">prev_p_k</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dilution</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev_p_k</span> <span class="o">+</span> <span class="n">dilution</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_p_k</span><span class="p">)</span>

    <span class="c1"># Calculate</span>
    <span class="n">new_p_k</span> <span class="o">=</span> <span class="n">op_choice</span> <span class="o">*</span> <span class="p">(</span><span class="n">prev_p_k</span> <span class="o">*</span> <span class="n">p_opk_approx</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prev_p_k</span> <span class="o">*</span> <span class="n">p_opk_approx</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
        <span class="mi">1</span> <span class="o">-</span> <span class="n">op_choice</span>
    <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">prev_p_k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_opk_approx</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prev_p_k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_opk_approx</span><span class="p">)))</span>

    <span class="c1"># Force probability sum to 1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_p_k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">new_p_k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">new_p_k</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_p_k</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">new_p_k</span></div>


<div class="viewcode-block" id="param_var_update"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.param_var_update">[docs]</a><span class="k">def</span> <span class="nf">param_var_update</span><span class="p">(</span>
    <span class="n">prev_p_op_mean</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">prev_param_var</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">prev_gradient</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">p_k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">volatility</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">volatility_dummy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    k-ToM updates its uncertainty / variance on its estimates of opponent's</span>
<span class="sd">    parameter values</span>
<span class="sd">    &gt;&gt;&gt; param_var_update(prev_param_mean = np.array([[0, 0, 0]]), \</span>
<span class="sd">        prev_param_var = np.array([[0, 0, 0]]), \</span>
<span class="sd">        prev_gradient = np.array([0, 0, 0]), p_k = np.array([1.]), \</span>
<span class="sd">        volatility = -2, volatility_dummy = None)</span>
<span class="sd">    array([[0.12692801, 0.        , 0.        ]])</span>
<span class="sd">    """</span>
    <span class="c1"># Dummy constant: sets volatility to 0 for all except volatility opponent</span>
    <span class="c1"># parameter estimates</span>
    <span class="k">if</span> <span class="n">volatility_dummy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">volatility_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">prev_param_var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">volatility_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="n">volatility_dummy</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Input variable transforms</span>
    <span class="n">prev_p_op_mean</span> <span class="o">=</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">prev_p_op_mean</span><span class="p">)</span>
    <span class="n">prev_param_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">prev_param_var</span><span class="p">)</span>
    <span class="n">volatility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">volatility</span><span class="p">)</span> <span class="o">*</span> <span class="n">volatility_dummy</span>

    <span class="c1"># Calculate</span>
    <span class="n">new_var</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span>
        <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">prev_param_var</span> <span class="o">+</span> <span class="n">volatility</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">p_k</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="o">*</span> <span class="n">prev_p_op_mean</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prev_p_op_mean</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="o">*</span> <span class="n">prev_gradient</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="p">)</span>

    <span class="c1"># Output variable transform</span>
    <span class="n">new_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_var</span></div>


<div class="viewcode-block" id="param_mean_update"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.param_mean_update">[docs]</a><span class="k">def</span> <span class="nf">param_mean_update</span><span class="p">(</span>
    <span class="n">prev_p_op_mean</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">prev_param_mean</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">prev_gradient</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">p_k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">param_var</span><span class="p">,</span> <span class="n">op_choice</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    k-ToM updates its estimates of opponent's parameter values</span>

<span class="sd">    &gt;&gt;&gt; param_mean_update(prev_p_op_mean, prev_param_mean = np.array([[0, 0, 0]]), prev_gradient = np.array([0, 0, 0]), p_k = np.array([0, 0, 0]), param_var, op_choice)</span>
<span class="sd">    """</span>
    <span class="c1"># Input variable transforms</span>
    <span class="n">param_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">param_var</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev_gradient</span>

    <span class="c1"># Calculate</span>
    <span class="n">new_param_mean</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">prev_param_mean</span>
        <span class="o">+</span> <span class="n">p_k</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="o">*</span> <span class="n">param_var</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">op_choice</span> <span class="o">-</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">prev_p_op_mean</span><span class="p">))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Used for numerical purposes (similar to the VBA package)</span>
    <span class="n">new_param_mean</span> <span class="o">=</span> <span class="n">logit</span><span class="p">(</span><span class="n">inv_logit</span><span class="p">(</span><span class="n">new_param_mean</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">new_param_mean</span></div>


<div class="viewcode-block" id="gradient_update"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.gradient_update">[docs]</a><span class="k">def</span> <span class="nf">gradient_update</span><span class="p">(</span>
    <span class="n">params</span><span class="p">,</span>
    <span class="n">p_op_mean</span><span class="p">,</span>
    <span class="n">param_mean</span><span class="p">,</span>
    <span class="n">sim_prev_internal_states</span><span class="p">,</span>
    <span class="n">sim_self_choice</span><span class="p">,</span>
    <span class="n">sim_op_choice</span><span class="p">,</span>
    <span class="n">sim_level</span><span class="p">,</span>
    <span class="n">sim_agent</span><span class="p">,</span>
    <span class="n">p_matrix</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">""""""</span>
    <span class="c1"># Make empty list for fillin in gradients</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param_mean</span><span class="p">))</span>

    <span class="c1"># The gradient is calculated for each parameter one at a time</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param_mean</span><span class="p">)):</span>
        <span class="c1"># Calculate increment</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="mf">1e-4</span> <span class="o">*</span> <span class="n">param_mean</span><span class="p">[</span><span class="n">param</span><span class="p">]),</span> <span class="mf">1e-4</span><span class="p">)</span>
        <span class="c1"># Use normal parameter estimates</span>
        <span class="n">param_mean_incr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">param_mean</span><span class="p">)</span>
        <span class="c1"># But increment the current parameter</span>
        <span class="n">param_mean_incr</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_mean</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span> <span class="n">increment</span>

        <span class="c1"># Make parameter structure similar to own</span>
        <span class="c1"># sim_params_incr = copy.deepcopy(params)</span>
        <span class="n">sim_params_incr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># Populate it with estimated values, including the increment</span>
        <span class="k">for</span> <span class="n">param_idx</span><span class="p">,</span> <span class="n">param_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="n">sim_params_incr</span><span class="p">[</span><span class="n">param_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_mean_incr</span><span class="p">[</span><span class="n">param_idx</span><span class="p">]</span>

        <span class="c1"># Simulate opponent learning using the incremented</span>
        <span class="n">sim_new_internal_states_incr</span> <span class="o">=</span> <span class="n">learning_function</span><span class="p">(</span>
            <span class="n">sim_prev_internal_states</span><span class="p">,</span>
            <span class="n">sim_params_incr</span><span class="p">,</span>
            <span class="n">sim_self_choice</span><span class="p">,</span>
            <span class="n">sim_op_choice</span><span class="p">,</span>
            <span class="n">sim_level</span><span class="p">,</span>
            <span class="n">sim_agent</span><span class="p">,</span>
            <span class="n">p_matrix</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Simulate opponent decision using incremented parameters</span>
        <span class="n">p_op_mean_incr</span> <span class="o">=</span> <span class="n">decision_function</span><span class="p">(</span>
            <span class="n">sim_new_internal_states_incr</span><span class="p">,</span>
            <span class="n">sim_params_incr</span><span class="p">,</span>
            <span class="n">sim_agent</span><span class="p">,</span>
            <span class="n">sim_level</span><span class="p">,</span>
            <span class="n">p_matrix</span><span class="p">,</span>
        <span class="p">)[</span>
            <span class="mi">0</span>
        <span class="p">]</span>  <span class="c1"># only use the first part of the output</span>

        <span class="c1"># Calculate the gradient: a measure of the size of the influence of</span>
        <span class="c1"># the incremented parameter value</span>
        <span class="n">gradient</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_op_mean_incr</span> <span class="o">-</span> <span class="n">p_op_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">increment</span>
    <span class="k">return</span> <span class="n">gradient</span></div>


<span class="c1"># Decision subfunctions</span>
<div class="viewcode-block" id="p_op0_fun"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.p_op0_fun">[docs]</a><span class="k">def</span> <span class="nf">p_op0_fun</span><span class="p">(</span><span class="n">p_op_mean0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">p_op_var0</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    0-ToM combines the mean and variance of its parameter estimate into a</span>
<span class="sd">    final choice probability estimate.</span>
<span class="sd">    NB: This is the function taken from the VBA package (Daunizeau 2014),</span>
<span class="sd">    which does not use 0-ToM's volatility parameter to avoid unidentifiability</span>
<span class="sd">    problems.</span>

<span class="sd">    &gt;&gt;&gt; p_op0_fun(p_op_mean0 = 0.7, p_op_var0 = 0.3)</span>
<span class="sd">    """</span>
    <span class="c1"># Constants</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.36</span>

    <span class="c1"># Input variable transforms</span>
    <span class="n">p_op_var0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">p_op_var0</span><span class="p">)</span>

    <span class="c1"># Calculate</span>
    <span class="n">p_op0</span> <span class="o">=</span> <span class="n">p_op_mean0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p_op_var0</span><span class="p">)</span>

    <span class="c1"># Output variable transforms</span>
    <span class="n">p_op0</span> <span class="o">=</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">p_op0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p_op0</span></div>


<div class="viewcode-block" id="p_opk_fun"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.p_opk_fun">[docs]</a><span class="k">def</span> <span class="nf">p_opk_fun</span><span class="p">(</span><span class="n">p_op_mean</span><span class="p">,</span> <span class="n">param_var</span><span class="p">,</span> <span class="n">gradient</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    k-ToM combines the mean choice probability estimate and the variances of</span>
<span class="sd">    its parameter estimates into a final choice probability estimate.</span>
<span class="sd">    NB: this is the function taken from the VBA package (Daunizeau 2014),</span>
<span class="sd">    which does not use k-ToM's volatility parameter to avoid unidentifiability</span>
<span class="sd">    issues.</span>
<span class="sd">    """</span>
    <span class="c1"># Constants</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.36</span>

    <span class="c1"># Input variable transforms</span>
    <span class="n">param_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">param_var</span><span class="p">)</span>

    <span class="c1"># Prepare variance by weighing with gradient</span>
    <span class="n">var_prepped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">param_var</span> <span class="o">*</span> <span class="n">gradient</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Calculate</span>
    <span class="n">p_opk</span> <span class="o">=</span> <span class="n">p_op_mean</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">var_prepped</span><span class="p">)</span>

    <span class="c1"># Output variable transform</span>
    <span class="n">p_opk</span> <span class="o">=</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">p_opk</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p_opk</span></div>


<div class="viewcode-block" id="expected_payoff_fun"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.expected_payoff_fun">[docs]</a><span class="k">def</span> <span class="nf">expected_payoff_fun</span><span class="p">(</span><span class="n">p_op</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">agent</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">p_matrix</span><span class="p">:</span> <span class="n">PayoffMatrix</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    p_op (0 &lt;= float &lt;= 1): The probability of the opponent choosing 1</span>
<span class="sd">    agent (0 &lt;= int &lt;= 1): the perspective of the agent</span>
<span class="sd">    p_matrix (PayoffMatix): a payoff matrix</span>

<span class="sd">    Calculate expected payoff of choosing 1 over 0</span>

<span class="sd">    Examples:</span>
<span class="sd">    &gt;&gt;&gt; staghunt = PayoffMatrix(name = 'staghunt')</span>
<span class="sd">    &gt;&gt;&gt; expected_payoff_fun(1, agent = 0, p_matrix = staghunt)</span>
<span class="sd">    2</span>
<span class="sd">    """</span>
    <span class="c1"># Calculate</span>
    <span class="n">expected_payoff</span> <span class="o">=</span> <span class="n">p_op</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">p_matrix</span><span class="o">.</span><span class="n">payoff</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">agent</span><span class="p">)</span> <span class="o">-</span> <span class="n">p_matrix</span><span class="o">.</span><span class="n">payoff</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">agent</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_op</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_matrix</span><span class="o">.</span><span class="n">payoff</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">agent</span><span class="p">)</span> <span class="o">-</span> <span class="n">p_matrix</span><span class="o">.</span><span class="n">payoff</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">agent</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">expected_payoff</span></div>


<div class="viewcode-block" id="softmax"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.softmax">[docs]</a><span class="k">def</span> <span class="nf">softmax</span><span class="p">(</span><span class="n">expected_payoff</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Softmax function for calculating own probability of choosing 1</span>
<span class="sd">    """</span>
    <span class="c1"># Extract necessary parameters</span>
    <span class="n">b_temp</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">"b_temp"</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">"bias"</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">"bias"</span><span class="p">]</span>

    <span class="c1"># Input variable transforms</span>
    <span class="n">b_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b_temp</span><span class="p">)</span>

    <span class="c1"># Divide by temperature parameter</span>
    <span class="n">expected_payoff</span> <span class="o">=</span> <span class="n">expected_payoff</span> <span class="o">/</span> <span class="n">b_temp</span>

    <span class="c1"># Add bias, optional</span>
    <span class="k">if</span> <span class="s2">"bias"</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">expected_payoff</span> <span class="o">=</span> <span class="n">expected_payoff</span> <span class="o">+</span> <span class="n">bias</span>

    <span class="c1"># The logit transform completes the softmax function</span>
    <span class="n">p_self</span> <span class="o">=</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">expected_payoff</span><span class="p">)</span>

    <span class="c1"># Set output bounds</span>
    <span class="k">if</span> <span class="n">p_self</span> <span class="o">&gt;</span> <span class="mf">0.999</span><span class="p">:</span>
        <span class="n">p_self</span> <span class="o">=</span> <span class="mf">0.999</span>
        <span class="c1"># warn("Choice probability constrained at upper bound 0.999 to avoid</span>
        <span class="c1"># rounding errors", Warning)</span>
    <span class="k">if</span> <span class="n">p_self</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">:</span>
        <span class="n">p_self</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="c1"># warn("Choice probability constrained at lower bound 0.001 to avoid</span>
        <span class="c1"># rounding errors", Warning)</span>

    <span class="k">return</span> <span class="n">p_self</span></div>


<span class="c1"># Full learning and decision functions</span>
<div class="viewcode-block" id="learning_function"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.learning_function">[docs]</a><span class="k">def</span> <span class="nf">learning_function</span><span class="p">(</span>
    <span class="n">prev_internal_states</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">params</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">self_choice</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">op_choice</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">agent</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">p_matrix</span> <span class="p">:</span> <span class="n">PayoffMatrix</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; penny = PayoffMatrix(name = "penny_competitive")</span>
<span class="sd">        &gt;&gt;&gt; prev_internal_states = {'opponent_states': {}, \</span>
<span class="sd">            'own_states': {'p_op_mean0': 0, 'p_op_var0': 0}}</span>
<span class="sd">        &gt;&gt;&gt; params = {'volatility': -2, 'b_temp': -1}</span>
<span class="sd">        &gt;&gt;&gt; learning_function(prev_internal_states, params, self_choice=1, \</span>
<span class="sd">            op_choice=1, level=0, agent=0, p_matrix=penny)</span>
<span class="sd">        {'opponent_states': {},</span>
<span class="sd">        'own_states': {'p_op_mean0': 0.44216598162254866,</span>
<span class="sd">        'p_op_var0': -0.12292276280308079}}</span>
<span class="sd">    """</span>
    <span class="c1"># Extract needed parameters</span>
    <span class="n">volatility</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">"volatility"</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">"dilution"</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">dilution</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">"dilution"</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dilution</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Make empty dictionary for storing updates states</span>
    <span class="n">new_internal_states</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">opponent_states</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># If the (simulated) agent is a 0-ToM</span>
    <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Extract needed variables</span>
        <span class="n">prev_p_op_mean0</span> <span class="o">=</span> <span class="n">prev_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_op_mean0"</span><span class="p">]</span>
        <span class="n">prev_p_op_var0</span> <span class="o">=</span> <span class="n">prev_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_op_var0"</span><span class="p">]</span>

        <span class="c1"># Update 0-ToM's uncertainty of opponent choice probability</span>
        <span class="n">p_op_var0</span> <span class="o">=</span> <span class="n">p_op_var0_update</span><span class="p">(</span><span class="n">prev_p_op_mean0</span><span class="p">,</span> <span class="n">prev_p_op_var0</span><span class="p">,</span> <span class="n">volatility</span><span class="p">)</span>

        <span class="c1"># Update 0-ToM's mean estimate of opponent choice probability</span>
        <span class="n">p_op_mean0</span> <span class="o">=</span> <span class="n">p_op_mean0_update</span><span class="p">(</span><span class="n">prev_p_op_mean0</span><span class="p">,</span> <span class="n">p_op_var0</span><span class="p">,</span> <span class="n">op_choice</span><span class="p">)</span>

        <span class="c1"># Gather own internal states</span>
        <span class="n">own_states</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"p_op_mean0"</span><span class="p">:</span> <span class="n">p_op_mean0</span><span class="p">,</span> <span class="s2">"p_op_var0"</span><span class="p">:</span> <span class="n">p_op_var0</span><span class="p">}</span>

    <span class="c1"># If the (simulated) agent is a k-ToM</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Extract needed variables</span>
        <span class="n">prev_p_k</span> <span class="o">=</span> <span class="n">prev_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_k"</span><span class="p">]</span>
        <span class="n">prev_p_op_mean</span> <span class="o">=</span> <span class="n">prev_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_op_mean"</span><span class="p">]</span>
        <span class="n">prev_param_mean</span> <span class="o">=</span> <span class="n">prev_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"param_mean"</span><span class="p">]</span>
        <span class="n">prev_param_var</span> <span class="o">=</span> <span class="n">prev_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"param_var"</span><span class="p">]</span>
        <span class="n">prev_gradient</span> <span class="o">=</span> <span class="n">prev_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"gradient"</span><span class="p">]</span>

        <span class="c1"># Update opponent level probabilities</span>
        <span class="n">p_opk_approx</span> <span class="o">=</span> <span class="n">p_opk_approx_fun</span><span class="p">(</span>
            <span class="n">prev_p_op_mean</span><span class="p">,</span> <span class="n">prev_param_var</span><span class="p">,</span> <span class="n">prev_gradient</span><span class="p">,</span> <span class="n">level</span>
        <span class="p">)</span>
        <span class="n">p_k</span> <span class="o">=</span> <span class="n">p_k_udpate</span><span class="p">(</span><span class="n">prev_p_k</span><span class="p">,</span> <span class="n">p_opk_approx</span><span class="p">,</span> <span class="n">op_choice</span><span class="p">,</span> <span class="n">dilution</span><span class="p">)</span>

        <span class="c1"># Update parameter estimates</span>
        <span class="n">param_var</span> <span class="o">=</span> <span class="n">param_var_update</span><span class="p">(</span>
            <span class="n">prev_p_op_mean</span><span class="p">,</span> <span class="n">prev_param_var</span><span class="p">,</span> <span class="n">prev_gradient</span><span class="p">,</span> <span class="n">p_k</span><span class="p">,</span> <span class="n">volatility</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">param_mean</span> <span class="o">=</span> <span class="n">param_mean_update</span><span class="p">(</span>
            <span class="n">prev_p_op_mean</span><span class="p">,</span> <span class="n">prev_param_mean</span><span class="p">,</span> <span class="n">prev_gradient</span><span class="p">,</span> <span class="n">p_k</span><span class="p">,</span> <span class="n">param_var</span><span class="p">,</span> <span class="n">op_choice</span>
        <span class="p">)</span>

        <span class="c1"># Do recursive simulating of opponent</span>
        <span class="c1"># Make empty structure for new means and gradients</span>
        <span class="n">p_op_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">level</span><span class="p">,</span> <span class="n">param_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># Prepare simulated opponent perspective</span>
        <span class="c1"># simulated perspective swtiches own and opponent role</span>
        <span class="n">sim_agent</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">agent</span>
        <span class="c1"># And previous choices</span>
        <span class="n">sim_self_choice</span><span class="p">,</span> <span class="n">sim_op_choice</span> <span class="o">=</span> <span class="n">op_choice</span><span class="p">,</span> <span class="n">self_choice</span>

        <span class="c1"># k-ToM simulates an opponent for each level below its own</span>
        <span class="k">for</span> <span class="n">sim_level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>

            <span class="c1"># Further preparation of simulated perspective</span>
            <span class="n">sim_prev_internal_states</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span>
                <span class="n">prev_internal_states</span><span class="p">[</span><span class="s2">"opponent_states"</span><span class="p">][</span><span class="n">sim_level</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Make parameter structure similar to own</span>
            <span class="n">sim_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="c1"># Populate it with estimated values</span>
            <span class="k">for</span> <span class="n">param_idx</span><span class="p">,</span> <span class="n">param_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="n">sim_params</span><span class="p">[</span><span class="n">param_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_mean</span><span class="p">[</span><span class="n">sim_level</span><span class="p">,</span> <span class="n">param_idx</span><span class="p">]</span>

            <span class="c1"># Simulate opponent learning (recursive)</span>
            <span class="n">sim_new_internal_states</span> <span class="o">=</span> <span class="n">learning_function</span><span class="p">(</span>
                <span class="n">sim_prev_internal_states</span><span class="p">,</span>
                <span class="n">sim_params</span><span class="p">,</span>
                <span class="n">sim_self_choice</span><span class="p">,</span>
                <span class="n">sim_op_choice</span><span class="p">,</span>
                <span class="n">sim_level</span><span class="p">,</span>
                <span class="n">sim_agent</span><span class="p">,</span>
                <span class="n">p_matrix</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

            <span class="c1"># Simulate opponent deciding</span>
            <span class="n">p_op_mean</span><span class="p">[</span><span class="n">sim_level</span><span class="p">]</span> <span class="o">=</span> <span class="n">decision_function</span><span class="p">(</span>
                <span class="n">sim_new_internal_states</span><span class="p">,</span> <span class="n">sim_params</span><span class="p">,</span> <span class="n">sim_agent</span><span class="p">,</span> <span class="n">sim_level</span><span class="p">,</span> <span class="n">p_matrix</span>
            <span class="p">)[</span>
                <span class="mi">0</span>
            <span class="p">]</span>  <span class="c1"># only use the first part of the output</span>

            <span class="c1"># Update gradient (recursive)</span>
            <span class="n">gradient</span><span class="p">[</span><span class="n">sim_level</span><span class="p">]</span> <span class="o">=</span> <span class="n">gradient_update</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span>
                <span class="n">p_op_mean</span><span class="p">[</span><span class="n">sim_level</span><span class="p">],</span>
                <span class="n">param_mean</span><span class="p">[</span><span class="n">sim_level</span><span class="p">],</span>
                <span class="n">sim_prev_internal_states</span><span class="p">,</span>
                <span class="n">sim_self_choice</span><span class="p">,</span>
                <span class="n">sim_op_choice</span><span class="p">,</span>
                <span class="n">sim_level</span><span class="p">,</span>
                <span class="n">sim_agent</span><span class="p">,</span>
                <span class="n">p_matrix</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

            <span class="c1"># Save opponent's states</span>
            <span class="n">opponent_states</span><span class="p">[</span><span class="n">sim_level</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim_new_internal_states</span>

        <span class="c1"># Gather own internal states</span>
        <span class="n">own_states</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"p_k"</span><span class="p">:</span> <span class="n">p_k</span><span class="p">,</span>
            <span class="s2">"p_op_mean"</span><span class="p">:</span> <span class="n">p_op_mean</span><span class="p">,</span>
            <span class="s2">"param_mean"</span><span class="p">:</span> <span class="n">param_mean</span><span class="p">,</span>
            <span class="s2">"param_var"</span><span class="p">:</span> <span class="n">param_var</span><span class="p">,</span>
            <span class="s2">"gradient"</span><span class="p">:</span> <span class="n">gradient</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="c1"># Save the updated estimated and own internal states</span>
    <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"opponent_states"</span><span class="p">]</span> <span class="o">=</span> <span class="n">opponent_states</span>
    <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">]</span> <span class="o">=</span> <span class="n">own_states</span>

    <span class="k">return</span> <span class="n">new_internal_states</span></div>


<div class="viewcode-block" id="decision_function"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.decision_function">[docs]</a><span class="k">def</span> <span class="nf">decision_function</span><span class="p">(</span><span class="n">new_internal_states</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">agent</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">p_matrix</span><span class="p">:</span> <span class="n">PayoffMatrix</span><span class="p">):</span>
    <span class="sd">"""</span>

<span class="sd">    Examples:</span>
<span class="sd">    &gt;&gt;&gt; penny = PayoffMatrix(name = "penny_competitive")</span>
<span class="sd">    &gt;&gt;&gt; new_internal_states = {'opponent_states': {}, \</span>
<span class="sd">    'own_states': {'p_op_mean0': 30, 'p_op_var0': 2}}</span>
<span class="sd">    &gt;&gt;&gt; params = {'volatility': -2, 'b_temp': -1}</span>
<span class="sd">    &gt;&gt;&gt; decision_function(new_internal_states, params, agent = 0, \</span>
<span class="sd">        level = 0, p_matrix = penny)</span>
<span class="sd">    -5.436561973742046</span>
<span class="sd">    """</span>
    <span class="c1"># If (simulated) agent is a 0-ToM</span>
    <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Extract needed variables</span>
        <span class="n">p_op_mean0</span> <span class="o">=</span> <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_op_mean0"</span><span class="p">]</span>
        <span class="n">p_op_var0</span> <span class="o">=</span> <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_op_var0"</span><span class="p">]</span>

        <span class="c1"># Estimate probability of opponent choice</span>
        <span class="n">p_op</span> <span class="o">=</span> <span class="n">p_op0_fun</span><span class="p">(</span><span class="n">p_op_mean0</span><span class="p">,</span> <span class="n">p_op_var0</span><span class="p">)</span>

    <span class="c1"># If the (simulated) agent is a k-ToM</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Extract needed variables</span>
        <span class="n">p_op_mean</span> <span class="o">=</span> <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_op_mean"</span><span class="p">]</span>
        <span class="n">param_var</span> <span class="o">=</span> <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"param_var"</span><span class="p">]</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"gradient"</span><span class="p">]</span>
        <span class="n">p_k</span> <span class="o">=</span> <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_k"</span><span class="p">]</span>

        <span class="c1"># Estimate probability of opponent choice for each simulated level</span>
        <span class="n">p_opk</span> <span class="o">=</span> <span class="n">p_opk_fun</span><span class="p">(</span><span class="n">p_op_mean</span><span class="p">,</span> <span class="n">param_var</span><span class="p">,</span> <span class="n">gradient</span><span class="p">)</span>

        <span class="c1"># Weigh choice probabilities by level probabilities for aggregate</span>
        <span class="c1"># choice probability estimate</span>
        <span class="n">p_op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_opk</span> <span class="o">*</span> <span class="n">p_k</span><span class="p">)</span>

    <span class="c1"># Calculate expected payoff</span>
    <span class="n">expected_payoff</span> <span class="o">=</span> <span class="n">expected_payoff_fun</span><span class="p">(</span><span class="n">p_op</span><span class="p">,</span> <span class="n">agent</span><span class="p">,</span> <span class="n">p_matrix</span><span class="p">)</span>

    <span class="c1"># Softmax</span>
    <span class="n">p_self</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">expected_payoff</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="c1"># Output variable transform</span>
    <span class="n">p_self</span> <span class="o">=</span> <span class="n">logit</span><span class="p">(</span><span class="n">p_self</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">p_self</span><span class="p">,</span> <span class="n">p_op</span><span class="p">)</span></div>


<span class="c1"># Full k-ToM Function</span>
<div class="viewcode-block" id="k_tom"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.k_tom">[docs]</a><span class="k">def</span> <span class="nf">k_tom</span><span class="p">(</span>
    <span class="n">prev_internal_states</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">self_choice</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">op_choice</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">agent</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">p_matrix</span> <span class="p">:</span> <span class="n">PayoffMatrix</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">""""""</span>

    <span class="c1"># Update estimates of opponent based on behaviour</span>
    <span class="k">if</span> <span class="n">self_choice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_internal_states</span> <span class="o">=</span> <span class="n">learning_function</span><span class="p">(</span>
            <span class="n">prev_internal_states</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">self_choice</span><span class="p">,</span>
            <span class="n">op_choice</span><span class="p">,</span>
            <span class="n">level</span><span class="p">,</span>
            <span class="n">agent</span><span class="p">,</span>
            <span class="n">p_matrix</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># If first round or missed round, make no update</span>
        <span class="n">new_internal_states</span> <span class="o">=</span> <span class="n">prev_internal_states</span>

    <span class="c1"># Calculate own decision probability</span>
    <span class="n">p_self</span><span class="p">,</span> <span class="n">p_op</span> <span class="o">=</span> <span class="n">decision_function</span><span class="p">(</span>
        <span class="n">new_internal_states</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">agent</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">p_matrix</span>
    <span class="p">)</span>

    <span class="c1"># Probability transform</span>
    <span class="n">p_self</span> <span class="o">=</span> <span class="n">inv_logit</span><span class="p">(</span><span class="n">p_self</span><span class="p">)</span>

    <span class="c1"># Save own choice probability</span>
    <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_self"</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_self</span>
    <span class="n">new_internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">][</span><span class="s2">"p_op"</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_op</span>

    <span class="c1"># Make decision</span>
    <span class="n">choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_self</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">choice</span><span class="p">,</span> <span class="n">new_internal_states</span><span class="p">)</span></div>


<span class="c1"># Initializing function</span>
<div class="viewcode-block" id="init_k_tom"><a class="viewcode-back" href="../../ktom_functions.html#tomsup.ktom_functions.init_k_tom">[docs]</a><span class="k">def</span> <span class="nf">init_k_tom</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">priors</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">"default"</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    &gt;&gt;&gt; init_k_tom(params = {'volatility': -2, 'b_temp': -1, 'bias':0 }, level=1, priors='default')</span>
<span class="sd">    """</span>
    <span class="c1"># If no priors are specified</span>
    <span class="k">if</span> <span class="n">priors</span> <span class="o">==</span> <span class="s2">"default"</span><span class="p">:</span>
        <span class="c1"># Set default priors</span>
        <span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"p_op_mean0"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"p_op_var0"</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>  <span class="c1"># Agnostic</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># the following is not used by 0-ToM</span>
            <span class="n">priors</span><span class="p">[</span><span class="s2">"p_op_mean"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">priors</span><span class="p">[</span><span class="s2">"param_mean"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
            <span class="n">priors</span><span class="p">[</span><span class="s2">"param_var"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
            <span class="n">priors</span><span class="p">[</span><span class="s2">"gradient"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
            <span class="k">if</span> <span class="s2">"bias"</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>  <span class="c1"># Following the original VBA implementation</span>
                <span class="n">priors</span><span class="p">[</span><span class="s2">"gradient"</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.999999997998081</span>

    <span class="c1"># Make empty list for prior internal states</span>
    <span class="n">internal_states</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">opponent_states</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># If the (simulated) agent i a 0-ToM</span>
    <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Set priors for choice probability estimate and its uncertainty</span>
        <span class="n">p_op_var0</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[</span><span class="s2">"p_op_var0"</span><span class="p">]</span>
        <span class="n">p_op_mean0</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[</span><span class="s2">"p_op_mean0"</span><span class="p">]</span>

        <span class="c1"># Gather own internal states</span>
        <span class="n">own_states</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"p_op_mean0"</span><span class="p">:</span> <span class="n">p_op_mean0</span><span class="p">,</span> <span class="s2">"p_op_var0"</span><span class="p">:</span> <span class="n">p_op_var0</span><span class="p">}</span>

    <span class="c1"># If the (simulated) agent is a k-ToM</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Set priors</span>
        <span class="n">p_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">level</span><span class="p">),</span> <span class="n">level</span><span class="p">)</span>
        <span class="n">p_op_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">priors</span><span class="p">[</span><span class="s2">"p_op_mean"</span><span class="p">],</span> <span class="n">level</span><span class="p">)</span>
        <span class="n">param_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">priors</span><span class="p">[</span><span class="s2">"param_var"</span><span class="p">],</span> <span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">param_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">priors</span><span class="p">[</span><span class="s2">"param_mean"</span><span class="p">],</span> <span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">priors</span><span class="p">[</span><span class="s2">"gradient"</span><span class="p">],</span> <span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># k-ToM simulates an opponent for each level below its own</span>
        <span class="k">for</span> <span class="n">level_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
            <span class="c1"># Simulate opponents to create the recursive data structure</span>
            <span class="n">sim_new_internal_states</span> <span class="o">=</span> <span class="n">init_k_tom</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">level_index</span><span class="p">,</span> <span class="n">priors</span><span class="p">)</span>
            <span class="c1"># Save opponent's states</span>
            <span class="n">opponent_states</span><span class="p">[</span><span class="n">level_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim_new_internal_states</span>

        <span class="c1"># Gather own internal states</span>
        <span class="n">own_states</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"p_k"</span><span class="p">:</span> <span class="n">p_k</span><span class="p">,</span>
            <span class="s2">"p_op_mean"</span><span class="p">:</span> <span class="n">p_op_mean</span><span class="p">,</span>
            <span class="s2">"param_mean"</span><span class="p">:</span> <span class="n">param_mean</span><span class="p">,</span>
            <span class="s2">"param_var"</span><span class="p">:</span> <span class="n">param_var</span><span class="p">,</span>
            <span class="s2">"gradient"</span><span class="p">:</span> <span class="n">gradient</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="c1"># Save own choice probability</span>
    <span class="n">own_states</span><span class="p">[</span><span class="s2">"p_self"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">own_states</span><span class="p">[</span><span class="s2">"p_op"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Save the updated estimated and own internal states</span>
    <span class="n">internal_states</span><span class="p">[</span><span class="s2">"opponent_states"</span><span class="p">]</span> <span class="o">=</span> <span class="n">opponent_states</span>
    <span class="n">internal_states</span><span class="p">[</span><span class="s2">"own_states"</span><span class="p">]</span> <span class="o">=</span> <span class="n">own_states</span>

    <span class="k">return</span> <span class="n">internal_states</span></div>
</pre></div>
      </article>
      <footer>
        
        <div class="related-pages">
          
          
        </div>

        <div class="related-information">
              Copyright &#169; 2021, Kenneth Enevoldsen and Peter Waade
            |
            Built with <a href="https://www.sphinx-doc.org/">Sphinx</a>
              and
              <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
              <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </main>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/main.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    </body>
</html>